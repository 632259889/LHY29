HLX Version 100
PixelShader<<<
#ifdef GL_ES
precision mediump float;
precision mediump int;
#endif

uniform float time;
uniform float duration;
uniform sampler2D hl_images[4];
uniform int object_id;
uniform vec2 hl_target_size;
varying vec2 hlf_texcoord;


vec3 rgbToHsv(vec3 color) {
	vec3 hsv;
	float mmin = min(color.r, min(color.g, color.b));
	float mmax = max(color.r, max(color.g, color.b));
	float delta = mmax - mmin;
	
	hsv.z = mmax;
	hsv.y = delta / mmax;

	if (color.r == mmax) {
		hsv.x = (color.g - color.b) / delta;
	} else if (color.g == mmax) {
		hsv.x = 2.0 + (color.b - color.r) / delta;
	} else {
		hsv.x = 4.0 + (color.r - color.g) / delta;
	}
	
	hsv.x *= 0.166667;
	if (hsv.x < 0.0) {
		hsv.x += 1.0;
	}
	
	return hsv;
}


vec3 hsvToRgb(vec3 hsv) {
	if (hsv.y == 0.0) {
		return vec3(hsv.z);
	} 
	else {
		float i;
		float aa, bb, cc, f;

		float h = hsv.x;
		float s = hsv.y;
		float b = hsv.z;

		if (h == 1.0) {
			h = 0.0;
		}

		h *= 6.0;
		i = floor(h);
		f = h - i;
		aa = b * (1.0 - s);
		bb = b * (1.0 - (s * f));
		cc = b * (1.0 - (s * (1.0 - f)));
		
		if (i == 0.0) return vec3(b, cc, aa);
		if (i == 1.0) return vec3(bb, b, aa);
		if (i == 2.0) return vec3(aa, b, cc);
		if (i == 3.0) return vec3(aa, bb, b);
		if (i == 4.0) return vec3(cc, aa, b);
		if (i == 5.0) return vec3(b, aa, bb);
	}
}

vec3 saturation(vec3 color, float sat) {
	const float lumaR = 0.212671;
	const float lumaG = 0.715160;
	const float lumaB = 0.072169;
	
	float v = sat + 1.0;
	float i = 1.0 - v;
	float r = i * lumaR;
	float g = i * lumaG;
	float b = i * lumaB;
	
	mat3 mat = mat3(r + v, r, r, g, g + v, g, b, b, b + v);
	
	return mat * color;
}



void main(){
	vec2 uv = hlf_texcoord;
	vec4 color = vec4(1, 1, 1, 1);
	vec3 color1;
	if (object_id == 0)
	{
		color = texture2D(hl_images[1], uv);
		
	}
	if (object_id >0)
	{
		color = texture2D(hl_images[0], uv);
	}
	
	color1.r = color.r * 0.843 + 0.157;
	color1.b = color.b * 0.882 + 0.118;
	color1.g = color.g;
	color1 *= vec3(1.0, 0.891, 0.733);
	
	vec3 hsv = rgbToHsv(color1);
	hsv.y = hsv.y * 0.55;
	color1 = hsvToRgb(hsv);
	
	color1 = saturation(color1, 0.65);
	color1 *= vec3(1.0, 0.891, 0.733);
	
	gl_FragColor = vec4(color1,color.a);
}

>>>PixelShader